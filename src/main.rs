//! A keyboard reader that echoes individual bytes generated by keystrokes.
//!
//! Copyright 2023 David Edwards
//!
//! Licensed under the Apache License, Version 2.0 (the "License");
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//!
//! <https://www.apache.org/licenses/LICENSE-2.0>
//!
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an "AS IS" BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

mod error;
mod opt;
mod print;
mod term;

use crate::error::Result;
use crate::opt::Options;
use crate::print::Printer;
use std::env;
use std::io::{self, Read, Write};
use std::process::ExitCode;

const USAGE: &str = include_str!("include/usage.in");

const PACKAGE_NAME: &str = env!("CARGO_PKG_NAME");
const PACKAGE_VERSION: &str = env!("CARGO_PKG_VERSION");
const BUILD_HASH: &str = env!("BUILD_HASH");
const BUILD_DATE: &str = env!("BUILD_DATE");

fn main() -> ExitCode {
    match run() {
        Err(e) => {
            println!("{e}");
            println!("use --help for options");
            ExitCode::from(1)
        }
        Ok(_) => ExitCode::SUCCESS,
    }
}

fn run() -> Result<()> {
    let opts = Options::parse(env::args().skip(1))?;
    if opts.help {
        println!("{USAGE}");
        Ok(())
    } else if opts.version {
        println!("{PACKAGE_NAME} {PACKAGE_VERSION} ({BUILD_HASH} {BUILD_DATE})");
        Ok(())
    } else {
        let pr = Printer::new(&opts);
        if term::is_tty() {
            process_tty(&pr)
        } else {
            process_file(&pr)
        }
    }
}

fn process_tty(pr: &Printer) -> Result<()> {
    println!("press ^C to exit (use 'keyb --help' for additional info)");
    let term = term::init()?;
    let mut tty = io::stdin().bytes();
    let mut highlight = true;
    loop {
        match tty.next().transpose()? {
            Some(b'\x03') => break,
            Some(c) => {
                pr.print(c, highlight);
                print!("\r");
                highlight = false;
            }
            None => {
                highlight = true;
            }
        }
        io::stdout().flush()?;
    }
    term::restore(&term)?;
    Ok(())
}

fn process_file(pr: &Printer) -> Result<()> {
    for b in io::stdin().bytes() {
        pr.print(b?, false);
    }
    Ok(())
}
