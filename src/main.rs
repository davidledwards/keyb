mod error;
mod opt;
mod term;

use crate::error::{Error, Result};
use crate::opt::Options;
use std::env;
use std::io::{self, Read, Write};
use std::process::ExitCode;

const USAGE: &str = r#"
usage: keyb OPTIONS
       keyb --help

  Echoes individual bytes read from the terminal until ^D is pressed. If STDIN
  is not a terminal, then the input stream is processed a sequence of bytes
  and terminates.

  This program is useful for observing sequences of bytes generated by various
  combinations of keystrokes. For example, Unicode characters would be encoded
  as a sequence of bytes.

  By default, each bytes read from the terminal is displayed on a single line
  of output as follows:

    ddd xx ooo [description]

  where ddd, xx, and ooo are the decimal, hexadecimal, and octal forms, and
  [description] is an optional printable form.
"#;

fn main() -> ExitCode {
    match run() {
        Err(e) => {
            match e {
                Error::Options(s) => {
                    println!("{}", s);
                    println!("use --help for options");
                }
                Error::IO(s) => println!("I/O error: {}", s),
            }
            ExitCode::from(1)
        }
        Ok(_) => ExitCode::SUCCESS,
    }
}

fn run() -> Result<()> {
    let opts = Options::parse(env::args().skip(1))?;
    if opts.help {
        println!("{}", USAGE);
        Ok(())
    } else {
        if term::is_tty() {
            process_tty()
        } else {
            process_file()
        }
    }
}

fn process_tty() -> Result<()> {
    println!("press ^D to exit");
    let term = term::init()?;
    let mut tty = io::stdin().bytes();
    loop {
        match tty.next().transpose()? {
            Some(b'\x04') => break,
            Some(c) => {
                print!("{0:3} {0:02X} {0:03o}", c);
                if let Some(s) = describe(c) {
                    print!(" {}", s);
                }
                println!("\r");
            }
            None => (),
        }
        io::stdout().flush()?;
    }
    term::restore(&term)?;
    Ok(())
}

fn process_file() -> Result<()> {
    for b in io::stdin().bytes() {
        let c = b?;
        print!("{0:3} {0:02X} {0:03o}", c);
        if let Some(s) = describe(c) {
            print!(" {}", s);
        }
        println!("");
    }
    Ok(())
}

const CONTROL_CODES: [&str; 32] = [
    "^@ \"\\0\"",
    "^A",
    "^B",
    "^C",
    "^D",
    "^E",
    "^F",
    "^G \"\\a\"",
    "^H \"\\b\"",
    "^I \"\\t\"",
    "^J \"\\n\"",
    "^K \"\\v\"",
    "^L \"\\f\"",
    "^M \"\\r\"",
    "^N",
    "^O",
    "^P",
    "^Q",
    "^R",
    "^S",
    "^T",
    "^U",
    "^V",
    "^W",
    "^X",
    "^Y",
    "^Z",
    "^[ \"ESC\"",
    "^\\",
    "^]",
    "^^",
    "^_",
];

fn describe(c: u8) -> Option<String> {
    if c > 127 {
        None
    } else {
        Some(match c {
            0..=31 => CONTROL_CODES[c as usize].to_string(),
            32..=126 => format!("{}", c as char),
            127 => "^? \"DEL\"".to_string(),
            _ => panic!(),
        })
    }
}
